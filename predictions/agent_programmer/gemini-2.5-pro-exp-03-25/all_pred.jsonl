{"instance_id": "astropy__astropy-12907", "model_patch": "--- astropy/modeling/separable.py\n+++ astropy/modeling/separable.py\n@@ -242,7 +242,7 @@\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, :right.shape[1]] = right\n \n     return np.hstack([cleft, cright])\n \n\\ No newline at end of file\n@@ -314,4 +314,4 @@\n # Maps modeling operators to a function computing and represents the\n # relationship of axes as an array of 0-es and 1-s\n _operators = {'&': _cstack, '|': _cdot, '+': _arith_oper, '-': _arith_oper,\n-              '*': _arith_oper, '/': _arith_oper, '**': _arith_oper}\n+              '*': _arith_oper, '/': _arith_oper, '**': _arith_oper}\n\\ No newline at end of file", "model_name_or_path": "agent_programmer_gemini-2.5-pro-exp-03-25"}
{"instance_id": "astropy__astropy-14182", "model_patch": "--- astropy/io/ascii/rst.py\n+++ astropy/io/ascii/rst.py\n@@ -0,0 +1,80 @@\n+# Licensed under a 3-clause BSD style license - see LICENSE.rst\n+\"\"\"An extensible ASCII table reader and writer.\n+\n+rst.py:\n+  Classes to read and write reStructuredText simple tables\n+\n+:Copyright: Smithsonian Astrophysical Observatory (2011)\n+:Author: Tom Aldcroft (aldcroft@head.cfa.harvard.edu)\n+\"\"\"\n+\n+\n+import re\n+\n+from . import core, fixedwidth\n+\n+__doctest_skip__ = [\"*\"]\n+\n+\n+class RSTHeader(fixedwidth.FixedWidthHeader):\n+    \"\"\"reStructuredText simple table header\"\"\"\n+\n+    position_line = r\"^(?:=+\\s+)+=+$\"\n+    \"\"\"Input table header line\"\"\"\n+    underline_char = \"=\"\n+    \"\"\"Character for header underline\"\"\"\n+\n+    def get_cols(self, lines):\n+        # Read the header line without comments (the first non-blank line)\n+        try:\n+            header_line = next(self.process_lines(lines))\n+        except StopIteration:\n+            raise core.InconsistentTableError(\"No header line found in table\")\n+\n+        # Define new column start and end based on the position line, i.e.\n+        # the line of ==== ===== ==== etc.\n+        self.position_line = next(self.process_lines(lines))\n+        if not re.match(self.position_line_re, self.position_line):\n+            raise core.InconsistentTableError(\n+                f'Line \"{self.position_line}\" does not match header position line regex'\n+                f' \"{self.position_line_re.pattern}\"'\n+            )\n+\n+        self._set_cols_from_widths()\n+        self.names = [x.strip() for x in self.splitter([header_line])[0]]\n+\n+\n+class RSTData(fixedwidth.FixedWidthData):\n+    \"\"\"reStructuredText simple table data\"\"\"\n+\n+    comment = None\n+    \"\"\"reStructuredText tables do not support comments\"\"\"\n+\n+\n+class RST(fixedwidth.FixedWidth):\n+    \"\"\"reStructuredText simple table format.\n+    Example::\n+\n+      ==== === =====\n+      Col1 Col2 Col3\n+      ==== === =====\n+         1   2   3.0\n+         4   5   6.0\n+      ==== === =====\n+\n+    See https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#simple-tables\n+    \"\"\"\n+\n+    _format_name = \"rst\"\n+    _description = \"reStructuredText simple table\"\n+\n+    def __init__(self, header_rows=None, **kwargs):\n+        super().__init__(header_rows=header_rows, **kwargs)\n+        # The RST reader allows for several space characters to be used as\n+        # delimiters, but the writer should default to a single space.\n+        if self.data.splitter.delimiter == r\"\\s\":\n+            self.data.splitter.delimiter = \" \"\n+        self.header = RSTHeader()\n+        self.data = RSTData()\n+        self.header.data = self.data\n+        self.data.header = self.header\n\\ No newline at end of file", "model_name_or_path": "agent_programmer_gemini-2.5-pro-exp-03-25"}
{"instance_id": "astropy__astropy-14365", "model_patch": "--- astropy/io/ascii/qdp.py\n+++ astropy/io/ascii/qdp.py\n@@ -60,7 +60,7 @@\n     ValueError: Unrecognized QDP line...\n     \"\"\"\n     _decimal_re = r\"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?\"\n-    _command_re = r\"READ [TS]ERR(\\s+[0-9]+)+\"\n+    _command_re = r\"READ\\s+[TS]ERR(\\s+[0-9]+)+\"\n \n     sep = delimiter\n     if delimiter is None:\n\\ No newline at end of file\n@@ -68,7 +68,7 @@\n     _new_re = rf\"NO({sep}NO)+\"\n     _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n     _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n-    _line_type_re = re.compile(_type_re)\n+    _line_type_re = re.compile(_type_re, re.IGNORECASE)\n     line = line.strip()\n     if not line:\n         return \"comment\"\n\\ No newline at end of file\n@@ -297,7 +297,10 @@\n                     # This should never happen, but just in case.\n                     if len(command) < 3:\n                         continue\n-                    err_specs[command[1].lower()] = [int(c) for c in command[2:]]\n+                    # command[0] is 'read', command[1] is 'serr' or 'terr' (case-insensitive)\n+                    err_specs[command[1].lower()] = [\n+                        int(c) for c in command[2:]\n+                    ]\n             if colnames is None:\n                 colnames = _interpret_err_lines(err_specs, ncol, names=input_colnames)\n \n\\ No newline at end of file\n@@ -639,4 +642,4 @@\n     def write(self, table):\n         self._check_multidim_table(table)\n         lines = _write_table_qdp(table, err_specs=self.err_specs)\n-        return lines\n+        return lines\n\\ No newline at end of file", "model_name_or_path": "agent_programmer_gemini-2.5-pro-exp-03-25"}
{"instance_id": "astropy__astropy-14995", "model_patch": "--- astropy/nddata/mixins/ndarithmetic.py\n+++ astropy/nddata/mixins/ndarithmetic.py\n@@ -512,18 +512,20 @@\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n-        # If only one mask is present we need not bother about any type checks\n         if (\n-            self.mask is None and operand is not None and operand.mask is None\n+            self.mask is None and (operand is None or operand.mask is None)\n         ) or handle_mask is None:\n             return None\n-        elif self.mask is None and operand is not None:\n-            # Make a copy so there is no reference in the result.\n+        elif self.mask is None:  # operand is not None and operand.mask is not None\n+            # Only operand.mask exists\n             return deepcopy(operand.mask)\n-        elif operand is None:\n+        elif operand is None or operand.mask is None:  # self.mask is not None here\n+            # Only self.mask exists\n             return deepcopy(self.mask)\n         else:\n-            # Now lets calculate the resulting mask (operation enforces copy)\n+            # Both self.mask and operand.mask exist and are not None\n+            if not callable(handle_mask):\n+                raise TypeError(f\"handle_mask must be a callable, got {handle_mask}\")\n             return handle_mask(self.mask, operand.mask, **kwds)\n \n     def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n\\ No newline at end of file\n@@ -747,4 +749,4 @@\n             )\n \n         # Return a new class based on the result\n-        return cls(result, **init_kwds)\n+        return cls(result, **init_kwds)\n\\ No newline at end of file", "model_name_or_path": "agent_programmer_gemini-2.5-pro-exp-03-25"}
{"instance_id": "astropy__astropy-6938", "model_patch": "--- astropy/io/fits/fitsrec.py\n+++ astropy/io/fits/fitsrec.py\n@@ -1261,7 +1261,7 @@\n \n         # Replace exponent separator in floating point numbers\n         if 'D' in format:\n-            output_field.replace(encode_ascii('E'), encode_ascii('D'))\n+            output_field[:] = output_field.replace(encode_ascii('E'), encode_ascii('D'))\n \n \n def _get_recarray_field(array, key):\n\\ No newline at end of file\n@@ -1328,4 +1328,4 @@\n     \"\"\"\n \n     dtypes = (d[0] for d in array.dtype.fields.values())\n-    return any(d.kind == 'U' for d in dtypes)\n+    return any(d.kind == 'U' for d in dtypes)\n\\ No newline at end of file", "model_name_or_path": "agent_programmer_gemini-2.5-pro-exp-03-25"}
